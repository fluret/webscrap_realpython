Table des matières
\begin{itemize}
\item Les fonctions en Python
\item L'importance des fonctions Python
Abstraction et réutilisation
Modularité
Séparation des espaces de noms


\item Abstraction et réutilisation
\item Modularité
\item Séparation des espaces de noms
\item Appels de fonctions et définitions
\item Passage d'un argument à l'autre
Arguments de position
Arguments par mot-clé
Paramètres par défaut
Valeurs mutables des paramètres par défaut
Pass-By-Value vs Pass-By-Référence en Pascal
Pass-By-Value vs Pass-By-Reference en Python
Résumé du passage d'arguments
Effets de bord


\item Arguments de position
\item Arguments sur les mots-clés
\item Paramètres par défaut
\item Valeurs mutables des paramètres par défaut
\item Pass-By-Value vs Pass-By-Référence en Pascal
\item Pass-By-Value vs Pass-By-Référence en Python
\item Résumé de la transmission des arguments
\item Effets secondaires
\item L'instruction return
Quitter une fonction
Retourner des données à l'appelant
Revoir les effets de bord


\item Quitter une fonction
\item Renvoi des données à l'appelant
\item Réexamen des effets secondaires
\item Listes d'arguments de longueur variable
Emballage des n-uplets d'arguments
Déballage des n-uplets d'arguments
Emballage d'un dictionnaire d'arguments
Déballage d'un dictionnaire d'arguments
Mettre le tout ensemble
Plusieurs déballages dans un appel de fonction Python


\item Emballage de n-uplets d'arguments
\item Décompression des n-uplets d'arguments
\item Emballage du dictionnaire des arguments
\item Déballage du dictionnaire des arguments
\item La mise en place de l'ensemble
\item Plusieurs décompactages dans un appel de fonction Python
\item Arguments par mot-clé uniquement
\item Arguments de position uniquement
\item Docstrings
\item Annotations de fonctions Python
\item Conclusion
\end{itemize}
\begin{itemize}
\item Abstraction et réutilisation
\item Modularité
\item Séparation des espaces de noms
\end{itemize}
\begin{itemize}
\item Arguments de position
\item Arguments sur les mots-clés
\item Paramètres par défaut
\item Valeurs mutables des paramètres par défaut
\item Pass-By-Value vs Pass-By-Référence en Pascal
\item Pass-By-Value vs Pass-By-Référence en Python
\item Résumé de la transmission des arguments
\item Effets secondaires
\end{itemize}
\begin{itemize}
\item Quitter une fonction
\item Renvoi des données à l'appelant
\item Réexamen des effets secondaires
\end{itemize}
\begin{itemize}
\item Emballage de n-uplets d'arguments
\item Décompression des n-uplets d'arguments
\item Emballage du dictionnaire des arguments
\item Déballage du dictionnaire des arguments
\item La mise en place de l'ensemble
\item Plusieurs décompactages dans un appel de fonction Python
\end{itemize}
 Regarder maintenant Ce tutoriel est accompagné d'un cours vidéo créé par l'équipe de Real Python. Regardez-le en même temps que le tutoriel écrit pour approfondir votre compréhension : Définir et appeler des fonctions Python
Dans les tutoriels précédents de cette série, vous avez vu de nombreux exemples démontrant l'utilisation des fonctions Python intégrées.  Dans ce tutoriel, vous apprendrez à définir votre propre fonction Python. Vous apprendrez quand diviser votre programme en fonctions distinctes définies par l'utilisateur et quels sont les outils dont vous aurez besoin pour ce faire.
Voici ce que vous apprendrez dans ce tutoriel :
\begin{itemize}
\item Comment les fonctions fonctionnent en Python et pourquoi elles sont utiles
\item Comment définir et appeler sa propre fonction Python ?
\item Mécanismes de transmission d'arguments à votre fonction
\item Comment renvoyer les données de votre fonction à l'environnement d'appel ?
\end{itemize}
Téléchargement PDF gratuit : Python 3 Cheat Sheet
 Répondez au quiz : Testez vos connaissances avec notre quiz interactif "Définir sa propre fonction Python". Vous recevrez un score à la fin du test pour vous aider à suivre vos progrès d'apprentissage :
Quiz interactif
Dans ce quiz, vous testerez votre compréhension de la définition de vos propres fonctions Python. Vous revisiterez à la fois les bases et la syntaxe plus complexe, comme les args et les kwargs, afin d'affiner votre connaissance des définitions de fonctions en Python.
\section{Les fonctions en Python}
Le concept mathématique de fonction vous est peut-être familier.  Une fonction est une relation ou une correspondance entre une ou plusieurs entrées et un ensemble de sorties.  En mathématiques, une fonction est généralement représentée comme suit :
Ici, f est une fonction qui opère sur les entrées x et y. La sortie de la fonction est z. Cependant, les fonctions de programmation sont beaucoup plus généralisées et polyvalentes que cette définition mathématique.  En fait, la définition et l'utilisation appropriées des fonctions sont si importantes pour le bon développement des logiciels que pratiquement tous les langages de programmation modernes prennent en charge à la fois les fonctions intégrées et les fonctions définies par l'utilisateur.
En programmation, une fonction est un bloc de code autonome qui encapsule une tâche spécifique ou un groupe de tâches connexes.  Dans les tutoriels précédents de cette série, vous avez été initié à certaines des fonctions intégrées fournies par Python. id(), par exemple, prend un argument et renvoie l'identifiant entier unique de cet objet :
len() renvoie la longueur de l'argument qui lui a été transmis :
any() prend un itérable comme argument et renvoie True si l'un des éléments de l'itérable est vrai et False sinon :
Chacune de ces fonctions intégrées exécute une tâche spécifique.  Le code qui accomplit la tâche est défini quelque part, mais vous n'avez pas besoin de savoir où ni même comment le code fonctionne.  Tout ce que vous devez savoir, c'est l'interface de la fonction :
\begin{enumerate}
\item Quels sont les arguments (s'il y en a) qu'il prend
\item Les valeurs qu'il renvoie (le cas échéant)
\end{enumerate}
Ensuite, vous appelez la fonction et lui transmettez les arguments appropriés.  L'exécution du programme se dirige vers le corps de code désigné et fait son travail.  Lorsque la fonction est terminée, l'exécution revient à votre code là où elle s'est arrêtée.  La fonction peut ou non renvoyer des données à utiliser par votre code, comme le font les exemples ci-dessus.
Lorsque vous définissez votre propre fonction Python, le fonctionnement est le même.  À partir d'un point quelconque de votre code, vous appellerez votre fonction Python et l'exécution du programme sera transférée au corps de code qui constitue la fonction.
Remarque : dans ce cas, vous saurez où se trouve le code et comment il fonctionne, car c'est vous qui l'avez écrit !
Lorsque la fonction est terminée, l'exécution revient à l'endroit où la fonction a été appelée.  Selon la manière dont vous avez conçu l'interface de la fonction, des données peuvent être transmises lors de l'appel de la fonction et des valeurs de retour peuvent être transmises à la fin de l'exécution de la fonction.
\section{L'importance des fonctions Python}
Pratiquement tous les langages de programmation utilisés aujourd'hui prennent en charge une forme de fonctions définies par l'utilisateur, bien qu'elles ne soient pas toujours appelées fonctions. Dans d'autres langages, elles peuvent être désignées par l'un des termes suivants :
\begin{itemize}
\item Sous-programmes
\item Procédures
\item Méthodes
\item Sous-programmes
\end{itemize}
Alors, pourquoi se donner la peine de définir des fonctions ?  Il y a plusieurs très bonnes raisons. Passons en revue quelques-unes d'entre elles.
Supposons que vous écriviez un code qui fasse quelque chose d'utile. Au fil du développement, vous vous apercevez que la tâche exécutée par ce code est une tâche dont vous avez souvent besoin, à différents endroits de votre application. Que devez-vous faire ? Vous pourriez simplement reproduire le code à l'infini, en utilisant la fonction copier-coller de votre éditeur.
Plus tard, vous déciderez probablement que le code en question doit être modifié. Vous trouverez quelque chose qui ne va pas et qui doit être corrigé, ou vous voudrez l'améliorer d'une manière ou d'une autre. Si des copies du code sont dispersées dans toute l'application, vous devrez apporter les modifications nécessaires à chaque endroit.
Remarque : à première vue, cette solution peut sembler raisonnable, mais à long terme, elle risque d'être un cauchemar en termes de maintenance ! Bien que votre éditeur de code puisse vous aider en fournissant une fonction de recherche et de remplacement, cette méthode est sujette aux erreurs et vous pourriez facilement introduire dans votre code des bogues qui seront difficiles à trouver.
Une meilleure solution consiste à définir une fonction Python qui exécute la tâche.  Partout dans votre application où vous devez accomplir la tâche, il vous suffit d'appeler la fonction. Par la suite, si vous décidez de modifier le fonctionnement de la fonction, vous n'aurez à modifier le code qu'à un seul endroit, celui où la fonction est définie.  Les modifications seront automatiquement prises en compte partout où la fonction est appelée.
L'abstraction de la fonctionnalité dans une définition de fonction est un exemple du principe DRY (Don't Repeat Yourself) du développement de logiciels.  Il s'agit sans doute de la motivation la plus forte pour l'utilisation des fonctions.
Les fonctions permettent de décomposer des processus complexes en étapes plus petites.  Imaginez, par exemple, que vous ayez un programme qui lit un fichier, traite le contenu du fichier et écrit un fichier de sortie. Votre code pourrait ressembler à ceci :
Dans cet exemple, le programme principal est constitué d'un tas de code enchaîné dans une longue séquence, avec des espaces blancs et des commentaires pour l'aider à s'organiser.  Toutefois, si le code devenait beaucoup plus long et complexe, vous auriez de plus en plus de mal à vous y retrouver.
Vous pouvez également structurer le code de la manière suivante :
Cet exemple est modulaire.  Au lieu de rassembler tout le code, il est divisé en fonctions distinctes, chacune d'entre elles se concentrant sur une tâche spécifique. Ces tâches sont la lecture, le traitement et l'écriture. Le programme principal n'a plus qu'à appeler chacune de ces fonctions à tour de rôle.
Remarque : le mot-clé def introduit une nouvelle définition de fonction Python.  Vous apprendrez tout cela très bientôt.
Dans la vie, vous faites ce genre de choses tout le temps, même si vous n'y pensez pas explicitement.  Si vous voulez déplacer des étagères pleines d'objets d'un côté à l'autre de votre garage, vous ne resteriez pas là à vous dire : "Oh, mon Dieu, il faut que je déplace tous ces objets là-bas !  Il faut que je déplace toutes ces choses là-bas !  Comment faire ?"  Vous diviserez le travail en plusieurs étapes faciles à gérer :
\begin{enumerate}
\item Retirez tous les produits des étagères.
\item Démontez les étagères.
\item Transportez les pièces de l'étagère à travers le garage jusqu'à leur nouvel emplacement.
\item Remonter les étagères.
\item Transporter les affaires à travers le garage.
\item Remettre les produits en rayon.
\end{enumerate}
La décomposition d'une tâche importante en sous-tâches plus petites permet de mieux réfléchir à cette tâche et de mieux la gérer.  Au fur et à mesure que les programmes se compliquent, il devient de plus en plus avantageux de les modulariser de cette manière.
Un espace de noms est une région d'un programme dans laquelle les identificateurs ont une signification.  Comme vous le verrez ci-dessous, lorsqu'une fonction Python est appelée, un nouvel espace de noms est créé pour cette fonction, distinct de tous les autres espaces de noms existants.
En pratique, les variables peuvent être définies et utilisées dans une fonction Python même si elles portent le même nom que des variables définies dans d'autres fonctions ou dans le programme principal. Dans ces cas, il n'y a pas de confusion ou d'interférence car elles sont conservées dans des espaces de noms distincts.
Cela signifie que lorsque vous écrivez du code à l'intérieur d'une fonction, vous pouvez utiliser des noms de variables et des identificateurs sans vous soucier de savoir s'ils sont déjà utilisés ailleurs en dehors de la fonction.  Cela permet de réduire considérablement le nombre d'erreurs dans le code.
Remarque : vous en apprendrez beaucoup plus sur les espaces de noms dans la suite de cette série.
Nous espérons que vous êtes suffisamment convaincu des vertus des fonctions et que vous avez envie d'en créer !  Voyons comment faire.
\section{Appels de fonctions et définitions}
La syntaxe habituelle pour définir une fonction Python est la suivante :
Les éléments de la définition sont expliqués dans le tableau ci-dessous :
Le dernier élément, <déclaration(s)>, est appelé le corps de la fonction.  Le corps est un bloc d'instructions qui sera exécuté lorsque la fonction est appelée.  Le corps d'une fonction Python est défini par l'indentation conformément à la règle du hors-jeu. C'est la même chose que les blocs de code associés à une structure de contrôle, comme une instruction if ou while.
La syntaxe pour appeler une fonction Python est la suivante :
Les <arguments> sont les valeurs transmises à la fonction. Ils correspondent aux <paramètres> de la définition de la fonction Python.  Vous pouvez définir une fonction qui ne prend aucun argument, mais les parenthèses sont toujours nécessaires.  Une définition de fonction et un appel de fonction doivent toujours inclure des parenthèses, même si elles sont vides.
Comme d'habitude, vous commencerez par un petit exemple et vous ajouterez de la complexité à partir de là.  En gardant à l'esprit la tradition mathématique, vous appellerez votre première fonction Python f().  Voici un fichier script, foo.py, qui définit et appelle f() :
Voici comment fonctionne ce code :
\begin{enumerate}
\item 
La ligne 1 utilise le mot-clé def pour indiquer qu'une fonction est en cours de définition.  L'exécution de l'instruction def crée simplement la définition de f().  Toutes les lignes suivantes qui sont indentées (lignes 2 à 3) font partie du corps de f() et sont enregistrées comme sa définition, mais elles ne sont pas encore exécutées.

\item 
La ligne 4 est un espace blanc entre la définition de la fonction et la première ligne du programme principal. Bien qu'il ne soit pas nécessaire d'un point de vue syntaxique, il est agréable de l'avoir. Pour en savoir plus sur les espaces blancs autour des définitions de fonctions Python de haut niveau, consultez Writing Beautiful Pythonic Code With PEP 8 (en anglais).

\item 
La ligne 5 est la première instruction qui n'est pas indentée parce qu'elle ne fait pas partie de la définition de f(). C'est le début du programme principal.  Lorsque le programme principal s'exécute, cette instruction est exécutée en premier.

\item 
La ligne 6 est un appel à f(). Notez que des parenthèses vides sont toujours nécessaires dans une définition de fonction et dans un appel de fonction, même en l'absence de paramètres ou d'arguments. L'exécution se poursuit jusqu'à f() et les instructions contenues dans le corps de f() sont exécutées.

\item 
La ligne 7 est la ligne suivante à exécuter une fois que le corps de f() est terminé. L'exécution revient à cette instruction print().

\end{enumerate}
La ligne 1 utilise le mot-clé def pour indiquer qu'une fonction est en cours de définition.  L'exécution de l'instruction def crée simplement la définition de f().  Toutes les lignes suivantes qui sont indentées (lignes 2 à 3) font partie du corps de f() et sont enregistrées comme sa définition, mais elles ne sont pas encore exécutées.
La ligne 4 est un espace blanc entre la définition de la fonction et la première ligne du programme principal. Bien qu'il ne soit pas nécessaire d'un point de vue syntaxique, il est agréable de l'avoir. Pour en savoir plus sur les espaces blancs autour des définitions de fonctions Python de haut niveau, consultez Writing Beautiful Pythonic Code With PEP 8 (en anglais).
La ligne 5 est la première instruction qui n'est pas indentée parce qu'elle ne fait pas partie de la définition de f(). C'est le début du programme principal.  Lorsque le programme principal s'exécute, cette instruction est exécutée en premier.
La ligne 6 est un appel à f(). Notez que des parenthèses vides sont toujours nécessaires dans une définition de fonction et dans un appel de fonction, même en l'absence de paramètres ou d'arguments. L'exécution se poursuit jusqu'à f() et les instructions contenues dans le corps de f() sont exécutées.
La ligne 7 est la ligne suivante à exécuter une fois que le corps de f() est terminé. L'exécution revient à cette instruction print().
La séquence d'exécution (ou flux de contrôle) de foo.py est illustrée dans le diagramme suivant :
Lorsque foo.py est exécuté à partir d'une invite de commande Windows, le résultat est le suivant :
Il peut arriver que vous souhaitiez définir une fonction vide qui ne fait rien.  C'est ce que l'on appelle un stub, qui est généralement un emplacement temporaire pour une fonction Python qui sera entièrement mise en œuvre ultérieurement.  Tout comme un bloc dans une structure de contrôle ne peut pas être vide, le corps d'une fonction ne peut pas l'être non plus.  Pour définir une fonction stub, utilisez l'instruction passstatement :
Comme vous pouvez le voir ci-dessus, un appel à une fonction stub est syntaxiquement valide mais ne fait rien.
\section{Transmission des arguments}
Jusqu'à présent, dans ce tutoriel, les fonctions que vous avez définies n'ont pas pris d'arguments.  Cela peut parfois être utile, et vous écrirez occasionnellement de telles fonctions. Le plus souvent, cependant, vous voudrez passer des données dans une fonction afin que son comportement puisse varier d'une invocation à l'autre. Voyons comment procéder.
La façon la plus simple de transmettre des arguments à une fonction Python est d'utiliser des arguments positionnels (également appelés arguments requis). Dans la définition de la fonction, vous spécifiez une liste de paramètres séparés par des virgules à l'intérieur des parenthèses :
Lorsque la fonction est appelée, vous spécifiez une liste d'arguments correspondante :
Les paramètres (qty, item et price) se comportent comme des variables définies localement pour la fonction.  Lorsque la fonction est appelée, les arguments transmis (6, "bananes" et 1,74) sont liés aux paramètres dans l'ordre, comme s'il s'agissait d'une affectation de variable :
Dans certains textes de programmation, les paramètres donnés dans la définition de la fonction sont appelés paramètres formels, et les arguments dans l'appel de la fonction sont appelés paramètres réels :
Bien que les arguments positionnels constituent le moyen le plus simple de transmettre des données à une fonction, ils offrent également le moins de flexibilité.  Pour commencer, l'ordre des arguments dans l'appel doit correspondre à l'ordre des paramètres dans la définition.  Bien entendu, rien ne vous empêche de spécifier des arguments positionnels dans le désordre :
La fonction peut même s'exécuter, comme dans l'exemple ci-dessus, mais il est très peu probable qu'elle produise des résultats corrects.  Il incombe au programmeur qui définit la fonction de documenter les arguments appropriés, et il incombe à l'utilisateur de la fonction de prendre connaissance de ces informations et de s'y conformer.
Dans le cas des arguments positionnels, les arguments de l'appel et les paramètres de la définition doivent concorder non seulement dans l'ordre, mais aussi en nombre. C'est la raison pour laquelle les arguments positionnels sont également appelés arguments obligatoires. Vous ne pouvez en omettre aucun lors de l'appel de la fonction :
Vous ne pouvez pas non plus en spécifier d'autres :
Les arguments positionnels sont conceptuellement simples à utiliser, mais ils ne sont pas très indulgents.  Vous devez spécifier le même nombre d'arguments dans l'appel de fonction qu'il y a de paramètres dans la définition, et exactement dans le même ordre.  Dans les sections suivantes, vous verrez des techniques de passage d'arguments qui assouplissent ces restrictions.
Lorsque vous appelez une fonction, vous pouvez spécifier des arguments sous la forme <mot-clé>=<valeur>.  Dans ce cas, chaque <mot-clé> doit correspondre à un paramètre de la définition de la fonction Python. Par exemple, la fonction f() définie précédemment peut être appelée avec des arguments de type mot-clé comme suit :
La référence à un mot-clé qui ne correspond à aucun des paramètres déclarés génère une exception :
L'utilisation d'arguments de type mot-clé lève la restriction sur l'ordre des arguments.  Chaque argument mot-clé désigne explicitement un paramètre spécifique par son nom, vous pouvez donc les spécifier dans n'importe quel ordre et Python saura toujours quel argument va avec quel paramètre :
Comme pour les arguments positionnels, le nombre d'arguments et de paramètres doit toujours correspondre :
Ainsi, les arguments par mot-clé permettent une certaine flexibilité dans l'ordre dans lequel les arguments de la fonction sont spécifiés, mais le nombre d'arguments reste rigide.
Vous pouvez appeler une fonction en utilisant des arguments positionnels et des mots-clés :
Lorsque des arguments de position et des arguments de mot-clé sont présents, tous les arguments de position doivent être placés en premier :
Une fois que vous avez spécifié un argument de mot-clé, il ne peut y avoir d'argument de position à sa droite.
Pour en savoir plus sur les paramètres positionnels et les mots-clés, consultez le cours Real Python Exploring Special Function Parameters.
Si un paramètre spécifié dans une définition de fonction Python a la forme <nom>=<valeur>, alors <valeur> devient une valeur par défaut pour ce paramètre. Les paramètres définis de cette manière sont appelés paramètres par défaut ou optionnels. Un exemple de définition de fonction avec des paramètres par défaut est présenté ci-dessous :
Lorsque cette version de f() est appelée, tout argument omis prend sa valeur par défaut :
En résumé :
\begin{itemize}
\item L'ordre et le nombre des arguments positionnels doivent correspondre à ceux des paramètres déclarés dans la définition de la fonction.
\item Les arguments des mots-clés doivent correspondre en nombre aux paramètres déclarés, mais ils peuvent être spécifiés dans un ordre arbitraire.
\item Les paramètres par défaut permettent d'omettre certains arguments lors de l'appel de la fonction.
\end{itemize}
Les choses peuvent devenir étranges si vous spécifiez une valeur de paramètre par défaut qui est un objet mutable.  Prenons l'exemple de cette définition de fonction Python :
f() prend un seul paramètre de liste, ajoute la chaîne "####" à la fin de la liste et renvoie le résultat :
La valeur par défaut du paramètre my_list est la liste vide, donc si f() est appelé sans aucun argument, la valeur de retour est une liste avec l'unique élément '###' :
Tout est logique jusqu'à présent.  Maintenant, que se passera-t-il si f() est appelé sans paramètres une deuxième et une troisième fois ?  Voyons ce qu'il en est :
Oups !  On aurait pu s'attendre à ce que chaque appel ultérieur renvoie également la liste singleton ['###'], comme le premier.  Au lieu de cela, la valeur de retour continue de croître.  Que s'est-il passé ?
En Python, les valeurs par défaut des paramètres ne sont définies qu'une seule fois lors de la définition de la fonction (c'est-à-dire lors de l'exécution de l'instruction def).  La valeur par défaut n'est pas redéfinie à chaque fois que la fonction est appelée.  Ainsi, chaque fois que vous appelez f() sans paramètre, vous exécutez .append() sur la même liste.
Vous pouvez en faire la démonstration avec id() :
L'identificateur d'objet affiché confirme que, lorsque my_list est autorisé à prendre la valeur par défaut, la valeur est le même objet à chaque appel.  Les listes étant mutables, chaque appel ultérieur à .append() allonge la liste. Il s'agit d'un piège courant et assez bien documenté lorsque vous utilisez un objet mutable comme valeur par défaut d'un paramètre.  Il peut conduire à un comportement confus du code et il est probablement préférable de l'éviter.
En guise de solution de contournement, envisagez d'utiliser une valeur d'argument par défaut qui signale qu'aucun argument n'a été spécifié.  Presque n'importe quelle valeur peut fonctionner, mais None est un choix courant.  Lorsque la valeur sentinelle indique qu'aucun argument n'est donné, créez une nouvelle liste vide à l'intérieur de la fonction :
Notez que cela garantit que ma_liste prend par défaut la forme d'une liste vide chaque fois que f() est appelée sans argument.
Dans la conception des langages de programmation, il existe deux paradigmes courants pour le passage d'un argument à une fonction :
\begin{enumerate}
\item Passage par la valeur : Une copie de l'argument est transmise à la fonction.
\item Passage par référence : Une référence à l'argument est transmise à la fonction.
\end{enumerate}
D'autres mécanismes existent, mais il s'agit essentiellement de variantes de ces deux mécanismes. Dans cette section, vous allez faire un petit détour par Python et vous pencher brièvement sur le Pascal, un langage de programmation qui fait une distinction particulièrement nette entre ces deux types de mécanismes.
Note : Ne vous inquiétez pas si vous n'êtes pas familier avec Pascal !  Les concepts sont similaires à ceux de Python, et les exemples présentés sont accompagnés d'explications suffisamment détaillées pour que vous puissiez vous faire une idée générale.  Une fois que vous aurez vu comment fonctionne le passage d'arguments en Pascal, nous reviendrons à Python, et vous verrez comment il se comporte.
Voici ce qu'il faut savoir sur la syntaxe du Pascal :
\begin{itemize}
\item Procédures : Une procédure en Pascal est similaire à une fonction en Python.
\item Colonne-équivalente : Cet opérateur (:=) est utilisé pour l'affectation en Pascal. Il est analogue au signe égal (=) en Python.
\item writeln() : Cette fonction affiche des données sur la console, comme la fonction print() de Python.
\end{itemize}
Une fois ce travail de base effectué, voici le premier exemple en Pascal :
Voici ce qui se passe :
\begin{itemize}
\item Ligne 12 : Le programme principal définit une variable entière x.
\item Ligne 15 : Il attribue initialement à x la valeur 5.
\item Ligne 17 : Il appelle ensuite la procédure f(), en passant x comme argument.
\item Ligne 5 : A l'intérieur de f(), l'instruction writeln() montre que le paramètre correspondant fx est initialement 5, la valeur passée.
\item Ligne 6 : la valeur 10 est alors attribuée à fx.
\item Ligne 7 : Cette valeur est vérifiée par l'instruction writeln() exécutée juste avant la sortie de f().
\item Ligne 18 : De retour dans l'environnement d'appel du programme principal, cette instruction writeln() montre qu'après le retour de f(), x vaut toujours 5, comme c'était le cas avant l'appel de la procédure.
\end{itemize}
L'exécution de ce code génère la sortie suivante :
Dans cet exemple, x est transmis par valeur, de sorte que f() ne reçoit qu'une copie.  Lorsque le paramètre correspondant fx est modifié, x n'est pas affecté.
Remarque : si vous voulez voir ce qui se passe, vous pouvez exécuter le code vous-même à l'aide d'un compilateur Pascal en ligne.
Il suffit de suivre les étapes suivantes :
\begin{enumerate}
\item Copiez le code de la boîte de code ci-dessus.
\item Visitez le compilateur Pascal en ligne.
\item Dans le champ de code à gauche, remplacez tout contenu existant par le code que vous avez copié à l'étape 1.
\item Cliquez sur Exécuter.
\end{enumerate}
Vous devriez obtenir le même résultat que ci-dessus.
Comparez maintenant avec l'exemple suivant :
Ce code est identique au premier exemple, à un changement près. Il s'agit de la présence du mot var devant fx dans la définition de la procédure f() à la ligne 3.  Cela indique que l'argument de f() est passé par référence.  Les modifications apportées au paramètre correspondant fx modifieront également l'argument dans l'environnement d'appel.
La sortie de ce code est la même que précédemment, à l'exception de la dernière ligne :
De nouveau, la valeur 10 est attribuée à fx à l'intérieur de f(), comme précédemment.  Mais cette fois, lorsque f() revient, x dans le programme principal a également été modifié.
Dans de nombreux langages de programmation, il s'agit essentiellement de la distinction entre passage par valeur et passage par référence :
\begin{itemize}
\item Si une variable est transmise par sa valeur, la fonction dispose d'une copie sur laquelle elle peut travailler, mais elle ne peut pas modifier la valeur originale dans l'environnement de l'appelant.
\item Si une variable est transmise par référence, toute modification apportée par la fonction au paramètre correspondant affectera la valeur dans l'environnement de l'appelant.
\end{itemize}
La raison en est la signification d'une référence dans ces langues.  Les valeurs des variables sont stockées en mémoire. En Pascal et dans les langages similaires, une référence est essentiellement l'adresse de cet emplacement mémoire, comme le montre la figure ci-dessous :
Dans le diagramme de gauche, la mémoire allouée à x se trouve dans l'espace de noms du programme principal.  Lorsque f() est appelé, x est transmis par valeur, de sorte que la mémoire pour le paramètre correspondant fx est allouée dans l'espace de noms de f(), et la valeur de x y est copiée.  Lorsque f() modifie fx, c'est cette copie locale qui est modifiée.  La valeur de x dans l'environnement d'appel n'est pas affectée.
Dans le diagramme de droite, x est transmis par référence.  Le paramètre correspondant fx pointe vers l'adresse réelle dans l'espace de noms du programme principal où la valeur de x est stockée.  Lorsque f() modifie fx, il modifie la valeur à cet endroit, tout comme si le programme principal modifiait x lui-même.
En Python, les paramètres sont-ils transmis par valeur ou par référence ?  La réponse est qu'ils ne sont ni l'un ni l'autre, exactement.  En effet, une référence n'a pas la même signification en Python qu'en Pascal.
Rappelons qu'en Python, chaque donnée est un objet. Une référence pointe vers un objet, et non vers un emplacement mémoire spécifique.  Cela signifie que l'affectation n'est pas interprétée de la même manière en Python et en Pascal.  Considérez la paire d'instructions suivante en Pascal :
Elles sont interprétées de la manière suivante :
\begin{itemize}
\item La variable x fait référence à un emplacement de mémoire spécifique.
\item La première instruction place la valeur 5 à cet endroit.
\item La déclaration suivante écrase le 5 et place 10 à la place.
\end{itemize}
En revanche, en Python, les instructions d'affectation analogues sont les suivantes :
Ces déclarations d'affectation ont la signification suivante :
\begin{itemize}
\item La première instruction fait pointer x sur un objet dont la valeur est 5.
\item L'instruction suivante réaffecte x en tant que nouvelle référence à un objet différent dont la valeur est 10. En d'autres termes, la deuxième affectation renvoie x à un objet différent dont la valeur est 10.
\end{itemize}
En Python, lorsque vous passez un argument à une fonction, un rebinding similaire se produit.  Prenons l'exemple suivant :
Dans le programme principal, l'instruction x = 5 à la ligne 4 crée une référence nommée x liée à un objet dont la valeur est 5. f() est ensuite appelé à la ligne 5, avec x comme argument.  Lorsque f() démarre, une nouvelle référence appelée fx est créée, qui pointe initialement sur le même objet 5 que x :
Cependant, lorsque l'instruction fx = 10 à la ligne 2 est exécutée, f() renvoie fx à un nouvel objet dont la valeur est 10.  Les deux références, x et fx, sont découplées l'une de l'autre. Rien d'autre que f() n'affectera x, et lorsque f() se terminera, x pointera toujours vers l'objet 5, comme c'était le cas avant l'appel de la fonction :
Vous pouvez confirmer tout cela en utilisant id().  Voici une version légèrement augmentée de l'exemple ci-dessus qui affiche les identifiants numériques des objets concernés :
Lorsque f() démarre, fx et x pointent tous deux vers le même objet, dont l'id() est 1357924048.  Après que f() a exécuté l'instruction fx = 10 à la ligne 3, fx pointe vers un objet différent dont l'id() est 1357924128.  La connexion avec l'objet original dans l'environnement d'appel est perdue.
Le passage d'arguments en Python est en quelque sorte un hybride entre le passage par la valeur et le passage par la référence.  Ce qui est transmis à la fonction est une référence à un objet, mais la référence est transmise par la valeur.
Remarque : le mécanisme de passage des arguments de Python a été appelé "pass-by-assignment" (passage par affectation). En effet, les noms des paramètres sont liés à des objets à l'entrée de la fonction en Python, et l'affectation est également le processus de liaison d'un nom à un objet. Vous pouvez également utiliser les termes pass-by-object, pass-by-object-reference ou pass-by-sharing.
Ce qu'il faut retenir, c'est qu'une fonction Python ne peut pas modifier la valeur d'un argument en réaffectant le paramètre correspondant à quelque chose d'autre. L'exemple suivant le démontre :
Ici, des objets de type int, dict, set, str et list sont passés à f() en tant qu'arguments. f() tente d'assigner chacun d'entre eux à l'objet chaîne 'foo', mais comme vous pouvez le voir, une fois de retour dans l'environnement d'appel, ils sont tous inchangés.  Dès que f() exécute l'affectation x = 'foo', la référence est rebondie et la connexion avec l'objet original est perdue.
Cela signifie-t-il qu'une fonction Python ne peut jamais modifier ses arguments ?  En fait, non, ce n'est pas le cas !  Regardez ce qui se passe ici :
Dans ce cas, l'argument de f() est une liste.  Lorsque f() est appelé, une référence à ma_liste est transmise.  Vous avez déjà vu que f() ne peut pas réaffecter ma_liste en gros. Si x était assigné à quelque chose d'autre, il serait lié à un objet différent et la connexion à ma_liste serait perdue.
Cependant, f() peut utiliser la référence pour effectuer des modifications à l'intérieur de my_list.  Ici, f() a modifié le premier élément.  Vous pouvez voir qu'une fois la fonction retournée, ma_liste a, en fait, été modifiée dans l'environnement d'appel. Le même concept s'applique à un dictionnaire :
Ici, f() utilise x comme référence pour effectuer une modification à l'intérieur de my_dict.  Cette modification est reflétée dans l'environnement d'appel après le retour de f().
Le passage d'argument en Python peut être résumé comme suit. Le passage d'un objet immuable, comme un int, str, tuple, ou frozenset, à une fonction Python agit comme un passage par valeur.  La fonction ne peut pas modifier l'objet dans l'environnement d'appel.
Le passage d'un objet mutable tel qu'une liste, un dict ou un ensemble agit un peu, mais pas exactement, comme le passage par référence.  La fonction ne peut pas réaffecter l'objet en gros, mais elle peut modifier des éléments en place dans l'objet, et ces changements seront reflétés dans l'environnement d'appel.
En Python, il est donc possible de modifier un argument à l'intérieur d'une fonction afin que le changement soit reflété dans l'environnement d'appel.  Mais faut-il le faire ? Il s'agit d'un exemple de ce que l'on appelle dans le jargon de la programmation un effet de bord.  
Plus généralement, on dit d'une fonction Python qu'elle provoque un effet de bord si elle modifie son environnement d'appel d'une manière ou d'une autre. La modification de la valeur d'un argument d'une fonction n'est qu'une des possibilités.
Note : Vous connaissez probablement les effets secondaires dans le domaine de la santé humaine, où le terme fait généralement référence à une conséquence involontaire d'un médicament. Il s'agit souvent d'une conséquence indésirable, comme des vomissements ou une sédation.  D'autre part, les effets secondaires peuvent être utilisés intentionnellement. Par exemple, certains médicaments stimulent l'appétit, ce qui peut être utilisé à son avantage, même si ce n'est pas l'intention première du médicament.
Le concept est similaire en programmation.  Si un effet secondaire est une partie bien documentée de la spécification de la fonction, et que l'utilisateur de la fonction est expressément conscient du moment et de la manière dont l'environnement d'appel peut être modifié, alors cela peut être acceptable. Mais un programmeur peut ne pas toujours documenter correctement les effets secondaires, ou il peut même ne pas être conscient que des effets secondaires se produisent.
Lorsqu'ils sont cachés ou inattendus, les effets secondaires peuvent entraîner des erreurs de programme très difficiles à détecter.  En règle générale, il est préférable de les éviter.
\section{La déclaration de retour}
Que peut donc faire une fonction Python ?  Après tout, dans de nombreux cas, si une fonction ne provoque pas de changement dans l'environnement qui l'appelle, il n'y a pas vraiment de raison de l'appeler. Comment une fonction doit-elle affecter son appelant ?
L'une des possibilités consiste à utiliser les valeurs de retour des fonctions. Une déclaration de retour dans une fonction Python a deux objectifs :
\begin{enumerate}
\item Il met immédiatement fin à la fonction et redonne le contrôle de l'exécution à l'appelant.
\item Elle fournit un mécanisme par lequel la fonction peut renvoyer des données à l'appelant.
\end{enumerate}
Au sein d'une fonction, l'instruction return entraîne la sortie immédiate de la fonction Python et le transfert de l'exécution à l'appelant :
Dans cet exemple, l'instruction return est en fait superflue.  Une fonction retourne à l'appelant lorsqu'elle tombe en bout de course, c'est-à-dire après l'exécution de la dernière instruction du corps de la fonction. Cette fonction se comporterait donc de manière identique sans l'instruction return.
Cependant, les instructions de retour ne doivent pas nécessairement se trouver à la fin d'une fonction. Elles peuvent apparaître n'importe où dans le corps d'une fonction, et même plusieurs fois.  Prenons l'exemple suivant :
Les deux premiers appels à f() n'entraînent aucune sortie, car une instruction de retour est exécutée et la fonction se termine prématurément, avant que l'instruction print() de la ligne 6 ne soit atteinte.
Ce type de paradigme peut être utile pour le contrôle des erreurs dans une fonction. Vous pouvez vérifier plusieurs conditions d'erreur au début de la fonction, avec des instructions de retour qui renvoient en cas de problème :
Si aucune des conditions d'erreur n'est rencontrée, la fonction peut poursuivre son traitement normal.
Outre la sortie d'une fonction, l'instruction return est également utilisée pour transmettre des données à l'appelant.  Si l'instruction return à l'intérieur d'une fonction Python est suivie d'une expression, alors dans l'environnement d'appel, l'appel de la fonction est évalué à la valeur de cette expression :
Ici, la valeur de l'expression f() à la ligne 5 est "foo", qui est ensuite assignée à la variable s.
Une fonction peut renvoyer n'importe quel type d'objet. En Python, cela signifie à peu près n'importe quoi. Dans l'environnement d'appel, l'appel de fonction peut être utilisé syntaxiquement de n'importe quelle manière qui a du sens pour le type d'objet retourné par la fonction.
Par exemple, dans ce code, f() renvoie un dictionnaire.  Dans l'environnement d'appel, l'expression f() représente donc un dictionnaire, et f()['baz'] est une référence clé valide dans ce dictionnaire :
Dans l'exemple suivant, f() renvoie une chaîne que vous pouvez découper comme n'importe quelle autre chaîne :
Ici, f() renvoie une liste qui peut être indexée ou découpée :
Si plusieurs expressions séparées par des virgules sont spécifiées dans une instruction de retour, elles sont regroupées et renvoyées sous la forme d'un tuple :
Lorsqu'aucune valeur de retour n'est donnée, une fonction Python renvoie la valeur spéciale Python None :
La même chose se produit si le corps de la fonction ne contient pas d'instruction de retour et que la fonction tombe à la fin :
Rappelons que None est une erreur lorsqu'il est évalué dans un contexte booléen.
Étant donné que les fonctions qui sortent par une instruction de retour nue ou qui tombent à la fin renvoient None, un appel à une telle fonction peut être utilisé dans un contexte booléen :
Ici, les appels à f() et g() sont falsy, donc f() ou g() le sont aussi, et la clause else s'exécute.
Supposons que vous souhaitiez écrire une fonction qui prenne un argument entier et le double.  En d'autres termes, vous voulez passer une variable entière à la fonction, et lorsque la fonction revient, la valeur de la variable dans l'environnement d'appel doit être le double de ce qu'elle était. En Pascal, vous pourriez réaliser cela en utilisant la méthode "pass-by-reference" :
L'exécution de ce code produit la sortie suivante, qui vérifie que double() modifie bien x dans l'environnement d'appel :
En Python, cela ne fonctionne pas.  Comme vous le savez maintenant, les entiers Python sont immuables, de sorte qu'une fonction Python ne peut pas modifier un argument entier par effet de bord :
Cependant, vous pouvez utiliser une valeur de retour pour obtenir un effet similaire. Il suffit d'écrire double() pour qu'il prenne un argument entier, le double et renvoie la valeur doublée.  L'appelant est alors responsable de l'affectation qui modifie la valeur originale :
Cette solution est sans doute préférable à la modification par effet de bord.  Il est très clair que x est modifié dans l'environnement de l'appelant parce que l'appelant le fait lui-même. Quoi qu'il en soit, c'est la seule option possible, car la modification par effet de bord ne fonctionne pas dans ce cas.
Cependant, même dans les cas où il est possible de modifier un argument par effet de bord, l'utilisation d'une valeur de retour peut s'avérer plus claire.  Supposons que vous souhaitiez doubler chaque élément d'une liste.  Les listes étant mutables, vous pouvez définir une fonction Python qui modifie la liste en place :
Contrairement à double() dans l'exemple précédent, double_list() fonctionne en fait comme prévu.  Si la documentation de la fonction indique clairement que le contenu de l'argument liste est modifié, il peut s'agir d'une implémentation raisonnable.
Cependant, vous pouvez également écrire double_list() pour renvoyer la liste souhaitée par la valeur de retour et permettre à l'appelant d'effectuer l'affectation, de la même manière que double() a été réécrite dans l'exemple précédent :
Les deux approches fonctionnent aussi bien l'une que l'autre.  Comme c'est souvent le cas, il s'agit d'une question de style, et les préférences personnelles varient.  Les effets de bord ne sont pas nécessairement un mal absolu, et ils ont leur place, mais comme pratiquement tout peut être renvoyé par une fonction, la même chose peut généralement être accomplie par le biais des valeurs de retour.
\section{Listes d'arguments de longueur variable}
Dans certains cas, lorsque vous définissez une fonction, il se peut que vous ne sachiez pas à l'avance combien d'arguments vous souhaitez qu'elle prenne.  Supposons, par exemple, que vous souhaitiez écrire une fonction Python qui calcule la moyenne de plusieurs valeurs.  Vous pourriez commencer par quelque chose comme ceci :
Tout va bien si l'on veut faire la moyenne de trois valeurs :
Cependant, comme vous l'avez déjà vu, lorsque des arguments positionnels sont utilisés, le nombre d'arguments passés doit correspondre au nombre de paramètres déclarés.  Il est donc évident que cette implémentation de avg() pour un nombre de valeurs différent de trois ne fonctionne pas bien :
Vous pouvez essayer de définir avg() avec des paramètres optionnels :
Cela permet de spécifier un nombre variable d'arguments.  Les appels suivants sont au moins syntaxiquement corrects :
Mais cette approche souffre encore de quelques problèmes. Tout d'abord, elle n'autorise que cinq arguments au maximum, et non un nombre arbitraire. Pire encore, il n'y a aucun moyen de faire la distinction entre les arguments qui ont été spécifiés et ceux qui ont été autorisés par défaut.  La fonction n'a aucun moyen de savoir combien d'arguments ont été transmis, et ne sait donc pas par quoi diviser :
Manifestement, cela ne suffit pas non plus.
Vous pourriez écrire avg() pour qu'elle prenne un seul argument de type liste :
Au moins, cela fonctionne.  Il autorise un nombre arbitraire de valeurs et produit un résultat correct.  En prime, cela fonctionne également lorsque l'argument est un tuple :
L'inconvénient est que l'étape supplémentaire consistant à regrouper les valeurs dans une liste ou un tuple n'est probablement pas quelque chose à laquelle l'utilisateur de la fonction s'attendrait, et ce n'est pas très élégant.  Chaque fois que vous trouvez un code Python qui semble inélégant, il y a probablement une meilleure option.
Dans ce cas, c'est effectivement le cas !  Python fournit un moyen de passer à une fonction un nombre variable d'arguments avec l'empaquetage et le dépaquetage des n-uplets d'arguments à l'aide de l'opérateur astérisque (*).
Lorsqu'un nom de paramètre dans une définition de fonction Python est précédé d'un astérisque (*), cela signifie que les arguments sont regroupés dans un n-uplet.  Tous les arguments correspondants dans l'appel de fonction sont regroupés dans un tuple auquel la fonction peut se référer par le nom du paramètre donné. Voici un exemple :
Dans la définition de f(), la spécification du paramètre *args indique l'empaquetage des n-uplets.  Dans chaque appel à f(), les arguments sont regroupés dans un tuple auquel la fonction peut se référer par le nom args.  N'importe quel nom peut être utilisé, mais args est si souvent choisi qu'il s'agit pratiquement d'un standard.
En utilisant l'empaquetage de tuple, vous pouvez nettoyer avg() comme suit :
Mieux encore, vous pouvez le nettoyer encore plus en remplaçant la boucle for par la fonction intégrée de Python sum(), qui additionne les valeurs numériques de n'importe quel itérable :
Maintenant, avg() est écrit de manière concise et fonctionne comme prévu.
Cependant, en fonction de l'utilisation qui sera faite de ce code, il peut y avoir encore du travail à faire.  Tel qu'il est écrit, avg() produira une exception TypeError si l'un des arguments n'est pas numérique :
Pour être aussi robuste que possible, vous devez ajouter du code pour vérifier que les arguments sont du bon type.  Plus loin dans cette série de tutoriels, vous apprendrez à attraper des exceptions comme TypeError et à les gérer de manière appropriée.  Vous pouvez également consulter Python Exceptions :  Une introduction.
Une opération analogue est disponible de l'autre côté de l'équation dans un appel de fonction Python. Lorsqu'un argument dans un appel de fonction est précédé d'un astérisque (*), cela indique que l'argument est un tuple qui doit être décompressé et transmis à la fonction en tant que valeurs séparées :
Dans cet exemple, *t dans l'appel de fonction indique que t est un tuple qui doit être décompressé.  Les valeurs décompressées "foo", "bar" et "baz" sont respectivement affectées aux paramètres x, y et z.
Bien que ce type de déballage soit appelé déballage de tuple, il ne fonctionne pas uniquement avec des tuples.  L'opérateur astérisque (*) peut être appliqué à n'importe quel itérable dans un appel de fonction Python.  Par exemple, une liste ou un ensemble peut également être décompressé :
Vous pouvez même utiliser l'emballage et le déballage de tuple en même temps :
Ici, f(*a) indique que la liste a doit être décompressée et que les éléments doivent être transmis à f() en tant que valeurs individuelles.  La spécification du paramètre *args entraîne l'empaquetage des valeurs dans le n-uplet args.
Python dispose d'un opérateur similaire, le double astérisque (**), qui peut être utilisé avec les paramètres et les arguments des fonctions Python pour spécifier l'empaquetage et le dépaquetage du dictionnaire. Dans une définition de fonction Python, faire précéder un paramètre d'un double astérisque (**) indique que les arguments correspondants, qui sont censés être des paires clé/valeur, doivent être placés dans un dictionnaire :
Dans ce cas, les arguments foo=1, bar=2 et baz=3 sont rassemblés dans un dictionnaire que la fonction peut référencer par le nom kwargs.  Là encore, n'importe quel nom peut être utilisé, mais le nom particulier kwargs (abréviation de keyword args) est presque standard.  Vous n'êtes pas obligé d'y adhérer, mais si vous le faites, toute personne familière avec les conventions de codage de Python saura immédiatement ce que vous voulez dire.
La décomposition d'un dictionnaire d'arguments est analogue à la décomposition d'un tuple d'arguments.  Lorsque le double astérisque (**) précède un argument dans un appel de fonction Python, il spécifie que l'argument est un dictionnaire qui doit être décompressé, les éléments résultants étant transmis à la fonction en tant qu'arguments de mot-clé :
Les éléments du dictionnaire d sont décompressés et transmis à f() en tant qu'arguments de mot-clé.  Ainsi, f(**d) est équivalent à f(a='foo', b=25, c='qux') :
En fait, vérifiez ceci :
Ici, dict(a='foo', b=25, c='qux') crée un dictionnaire à partir des paires clé/valeur spécifiées.  Ensuite, l'opérateur double astérisque (**) le décompresse et transmet les mots-clés à f().
Considérez *args comme une liste d'arguments positionnels de longueur variable, et **kwargs comme une liste d'arguments de mots-clés de longueur variable.
Note : Pour un autre aperçu des *args et **kwargs, voir Python args and kwargs : Démystifié.
Les trois paramètres positionnels standard, *args et **kwargs, peuvent être utilisés dans une définition de fonction Python. Si c'est le cas, ils doivent être spécifiés dans cet ordre :
Cela offre à peu près toute la flexibilité dont on peut avoir besoin dans une interface de fonction !
La version 3.5 de Python a introduit la prise en charge de généralisations supplémentaires en matière de décompactage, comme indiqué dans le PEP 448.  Ces améliorations permettent notamment d'effectuer plusieurs décompactages en un seul appel de fonction Python :
Vous pouvez également spécifier plusieurs décompressions de dictionnaires dans un appel de fonction Python :
Remarque : cette amélioration n'est disponible que dans la version 3.5 ou ultérieure de Python.  Si vous essayez de le faire avec une version antérieure, vous obtiendrez une exception de type SyntaxError.
Par ailleurs, les opérateurs de déballage * et ** ne s'appliquent pas uniquement aux variables, comme dans les exemples ci-dessus.  Vous pouvez également les utiliser avec des littéraux itérables :
Ici, les listes littérales [1, 2, 3] et [4, 5, 6] sont spécifiées pour le déballage de tuple, et les dictionnaires littéraux {'a' : 1, 'b' : 2} et {'x' : 3, 'y' : 4} sont spécifiés pour le déballage des dictionnaires.
\section{Arguments par mot-clé uniquement}
Une fonction Python dans la version 3.x peut être définie de telle sorte qu'elle prenne des arguments de type mot-clé uniquement.  Il s'agit d'arguments de fonction qui doivent être spécifiés par mot-clé.  Examinons une situation dans laquelle cela peut s'avérer utile.
Supposons que vous souhaitiez écrire une fonction Python qui prenne un nombre variable d'arguments de type chaîne de caractères, les concatène ensemble en les séparant par un point ("."), et les imprime sur la console.  Quelque chose comme ceci fera l'affaire pour commencer :
Dans l'état actuel des choses, le préfixe de sortie est codé en dur sous la forme de la chaîne "->".  Que se passe-t-il si vous souhaitez modifier la fonction pour qu'elle accepte également ce préfixe en tant qu'argument, afin que l'utilisateur puisse spécifier autre chose ?  Voici une possibilité :
Cela fonctionne comme annoncé, mais cette solution présente quelques inconvénients :
\begin{enumerate}
\item 
La chaîne de préfixe est regroupée avec les chaînes à concaténer.  Il ne ressort pas clairement de l'appel de la fonction que le premier argument est traité différemment des autres.  Pour le savoir, il faut revenir en arrière et consulter la définition de la fonction.

\item 
n'est pas facultatif.  Il doit toujours être inclus, et il n'y a aucun moyen de prendre une valeur par défaut.

\end{enumerate}
La chaîne de préfixe est regroupée avec les chaînes à concaténer.  Il ne ressort pas clairement de l'appel de la fonction que le premier argument est traité différemment des autres.  Pour le savoir, il faut revenir en arrière et consulter la définition de la fonction.
n'est pas facultatif.  Il doit toujours être inclus, et il n'y a aucun moyen de prendre une valeur par défaut.
On peut penser qu'il est possible de résoudre le second problème en spécifiant un paramètre avec une valeur par défaut, comme ceci, par exemple :
Malheureusement, cela ne fonctionne pas tout à fait correctement. prefix est un paramètre positionnel, l'interpréteur suppose donc que le premier argument spécifié dans l'appel de la fonction est le préfixe de sortie prévu.  Cela signifie qu'il n'y a aucun moyen de l'omettre et d'obtenir la valeur par défaut :
Que se passe-t-il si vous essayez de spécifier préfixe comme argument de mot-clé ?  Eh bien, vous ne pouvez pas le spécifier en premier :
Comme vous l'avez vu précédemment, lorsque les deux types d'arguments sont donnés, tous les arguments de position doivent être placés avant les arguments de mot-clé.
Cependant, vous ne pouvez pas non plus spécifier qu'il s'agit de la dernière :
Encore une fois, prefix est un paramètre positionnel, donc il est assigné au premier argument spécifié dans l'appel (qui est 'a' dans ce cas).  Ensuite, lorsqu'il est à nouveau spécifié comme argument de mot-clé à la fin, Python pense qu'il a été assigné deux fois.
Les paramètres à mot-clé uniquement permettent de résoudre ce dilemme.  Dans la définition de la fonction, spécifiez *args pour indiquer un nombre variable d'arguments positionnels, puis spécifiez préfixe après cela :
Dans ce cas, prefix devient un paramètre de mot-clé uniquement.  Sa valeur ne sera jamais remplie par un argument positionnel.  Il ne peut être spécifié que par un argument de mot-clé nommé :
Notez que cela n'est possible qu'avec Python 3.  Dans les versions 2.x de Python, la spécification de paramètres supplémentaires après le paramètre d'arguments variables *args entraîne une erreur.
Les arguments par mot-clé uniquement permettent à une fonction Python de prendre un nombre variable d'arguments, suivis d'une ou plusieurs options supplémentaires en tant qu'arguments par mot-clé.  Si vous souhaitez modifier concat() de manière à ce que le caractère de séparation puisse être spécifié de manière optionnelle, vous pouvez ajouter un argument supplémentaire de type mot-clé uniquement :
Si la définition d'une fonction attribue une valeur par défaut à un paramètre exclusivement constitué de mots-clés (comme dans l'exemple ci-dessus) et que le mot-clé est omis lors de l'appel de la fonction, c'est la valeur par défaut qui est fournie :
En revanche, si le paramètre n'a pas de valeur par défaut, il devient obligatoire et le fait de ne pas le spécifier entraîne une erreur :
Que faire si vous souhaitez définir une fonction Python qui prend un argument de type mot-clé uniquement, mais qui ne prend pas un nombre variable d'arguments positionnels ?  Par exemple, la fonction suivante effectue l'opération spécifiée sur deux arguments numériques :
Si vous vouliez faire de op un paramètre de mot-clé uniquement, vous pourriez ajouter un paramètre d'argument de variable fictive et l'ignorer :
Le problème de cette solution est que *ignore absorbe tous les arguments positionnels superflus qui pourraient être inclus :
Dans cet exemple, l'argument supplémentaire ne devrait pas être là (comme l'annonce l'argument lui-même).  Au lieu de réussir tranquillement, il devrait vraiment provoquer une erreur.  Le fait que ce ne soit pas le cas est, au mieux, désordonné.  Au pire, cela peut entraîner un résultat qui semble trompeur :
Pour remédier à cela, la version 3 permet à un paramètre d'argument variable dans une définition de fonction Python de n'être qu'un astérisque nu (*), le nom étant omis :
L'argument variable nu paramètre * indique qu'il n'y a plus de paramètres positionnels. Ce comportement génère des messages d'erreur appropriés si des paramètres supplémentaires sont spécifiés. Il permet aux paramètres de type mot-clé de suivre.
\section{Arguments de position uniquement}
Depuis Python 3.8, les paramètres des fonctions peuvent également être déclarés uniquement en position, ce qui signifie que les arguments correspondants doivent être fournis en position et ne peuvent pas être spécifiés par mot-clé.
Pour désigner certains paramètres comme étant uniquement positionnels, vous devez spécifier une barre oblique (/) dans la liste des paramètres d'une définition de fonction.  Tous les paramètres situés à gauche de la barre oblique (/) doivent être spécifiés en position. Par exemple, dans la définition de fonction suivante, x et y sont des paramètres positionnels uniquement, mais z peut être spécifié par mot-clé :
Cela signifie que les appels suivants sont valables :
L'appel suivant à f() n'est cependant pas valide :
Les désignateurs "position uniquement" et "mot-clé uniquement" peuvent tous deux être utilisés dans la même définition de fonction :
Dans cet exemple :
\begin{itemize}
\item x et y sont uniquement positionnels.
\item a et b sont des mots-clés uniquement.
\item z et w peuvent être spécifiés en position ou par mot-clé.
\end{itemize}
Pour plus d'informations sur les paramètres positionnels uniquement, voir les points forts de la version 3.8 de Python et le tutoriel What Are Python Asterisk and Slash Special Parameters For ?
\section{Docstrings}
Lorsque la première instruction du corps d'une fonction Python est une chaîne de caractères littérale, on parle de docstring de la fonction.  Une docstring est utilisée pour fournir de la documentation sur une fonction.  Elle peut contenir l'objectif de la fonction, les arguments qu'elle prend, des informations sur les valeurs de retour ou toute autre information que vous jugez utile.
Voici un exemple de définition de fonction avec une chaîne de caractères :
Techniquement, les chaînes de documents peuvent utiliser n'importe quel mécanisme de citation de Python, mais la convention recommandée est d'utiliser des guillemets triples en utilisant des caractères de guillemets doubles ("""), comme indiqué ci-dessus.  Si la docstring tient sur une ligne, les guillemets fermants doivent être sur la même ligne que les guillemets ouvrants.
Les chaînes de documentation sur plusieurs lignes sont utilisées pour les documents plus longs.  Une chaîne de documentation multi-lignes doit comporter une ligne de résumé, suivie d'une ligne vide, puis d'une description plus détaillée.  Les guillemets fermants doivent être placés sur une ligne distincte :
Le formatage des chaînes de documents et les conventions sémantiques sont détaillés dans la PEP 257.
Lorsqu'une chaîne de documentation est définie, l'interpréteur Python l'attribue à un attribut spécial de la fonction appelé __doc__. Cet attribut fait partie d'un ensemble d'identifiants spécialisés en Python, parfois appelés attributs ou méthodes magiques, parce qu'ils offrent des fonctionnalités particulières au langage.  
Note : Ces attributs sont également désignés par les surnoms colorés dunder attributes et dunder methods. Le mot "dunder" combine le "d" de double et le "under" du caractère de soulignement (_). Vous rencontrerez de nombreux autres attributs et méthodes de type "dunder" dans les prochains tutoriels de cette série.
Vous pouvez accéder à la docstring d'une fonction avec l'expression <nom_de_la_fonction>.__doc__.  Les chaînes de documentation des exemples ci-dessus peuvent être affichées comme suit :
Dans l'interpréteur Python interactif, vous pouvez taper help(<nom_de_fonction>) pour afficher la docstring de <nom_de_fonction> :
Il est considéré comme une bonne pratique de codage de spécifier une chaîne de documentation pour chaque fonction Python que vous définissez.  Pour en savoir plus sur les docstrings, consultez Documenting Python Code : Un guide complet.
\section{Annotations de fonctions Python}
Depuis la version 3.0, Python propose une fonctionnalité supplémentaire pour documenter une fonction, appelée annotation de fonction.  Les annotations permettent d'attacher des métadonnées aux paramètres et à la valeur de retour d'une fonction.
Pour ajouter une annotation à un paramètre d'une fonction Python, insérez les deux points ( :) suivis d'une expression quelconque après le nom du paramètre dans la définition de la fonction.  Pour ajouter une annotation à la valeur de retour, ajoutez les caractères -> et une expression quelconque entre la parenthèse fermante de la liste des paramètres et les deux-points qui terminent l'en-tête de la fonction. Voici un exemple :
L'annotation du paramètre a est la chaîne "<a>", celle de b la chaîne "<b>" et celle de la valeur de retour de la fonction la chaîne "<ret_value>".
L'interprète Python crée un dictionnaire à partir des annotations et les affecte à un autre attribut dunder spécial de la fonction appelé __annotations__.  Les annotations de la fonction Python f() présentée ci-dessus peuvent être affichées comme suit :
Les clés des paramètres sont les noms des paramètres. La clé de la valeur de retour est la chaîne "return" :
Notez que les annotations ne sont pas limitées à des valeurs de type chaîne de caractères. Il peut s'agir de n'importe quelle expression ou objet. Par exemple, vous pouvez annoter avec des objets de type :
Une annotation peut même être un objet composite comme une liste ou un dictionnaire, de sorte qu'il est possible d'attacher plusieurs éléments de métadonnées aux paramètres et à la valeur de retour :
Dans l'exemple ci-dessus, une annotation est attachée au paramètre r et à la valeur de retour.  Chaque annotation est un dictionnaire contenant une description sous forme de chaîne et un objet de type.
Si vous voulez attribuer une valeur par défaut à un paramètre qui a une annotation, la valeur par défaut est placée après l'annotation :
Que font les annotations ?  Franchement, elles ne servent pas à grand-chose.  Elles sont juste là.  Reprenons l'un des exemples ci-dessus, mais en y apportant quelques modifications mineures :
Que se passe-t-il ici ?  Les annotations de f() indiquent que le premier argument est int, le second argument str, et la valeur de retour float.  Mais l'appel suivant à f() enfreint toutes les règles !  Les arguments sont respectivement str et float, et la valeur de retour est un tuple.  Pourtant, l'interpréteur laisse passer tout cela sans se plaindre.
Les annotations n'imposent aucune restriction sémantique au code.  Il s'agit simplement de métadonnées attachées aux paramètres et à la valeur de retour de la fonction Python.  Python les range consciencieusement dans un dictionnaire, assigne le dictionnaire à l'attribut __annotations__ de la fonction, et c'est tout.  Les annotations sont totalement facultatives et n'ont aucun impact sur l'exécution des fonctions Python.
Pour citer Amahl dans Amahl et les visiteurs de la nuit, "A quoi bon l'avoir alors ?".
Tout d'abord, les annotations constituent une bonne documentation.  Vous pouvez spécifier les mêmes informations dans la docstring, bien sûr, mais le fait de les placer directement dans la définition de la fonction ajoute de la clarté.  Les types des arguments et de la valeur de retour sont évidents à première vue pour un en-tête de fonction comme celui-ci :
Certes, l'interprète n'impose pas le respect des types spécifiés, mais ils sont au moins clairs pour quelqu'un qui lit la définition de la fonction.
Plongée profonde : Renforcer la vérification de type
Si vous le souhaitez, vous pouvez ajouter du code pour appliquer les types spécifiés dans les annotations de la fonction. Voici une fonction qui vérifie le type réel de chaque argument par rapport à ce qui est spécifié dans l'annotation du paramètre correspondant. Elle affiche True s'ils correspondent et False s'ils ne correspondent pas :
(Le module inspect contient des fonctions qui permettent d'obtenir des informations utiles sur les objets vivants - dans ce cas, la fonction f()).
Une fonction définie comme celle décrite ci-dessus pourrait, si elle le souhaite, prendre des mesures correctives lorsqu'elle détecte que les arguments transmis ne sont pas conformes aux types spécifiés dans les annotations.
En fait, un schéma d'utilisation des annotations pour effectuer une vérification statique des types en Python est décrit dans le PEP 484.  Il existe un vérificateur de type statique gratuit pour Python, appelé mypy, qui s'appuie sur la spécification PEP 484.
L'utilisation des annotations présente également un autre avantage.  Le format standardisé dans lequel les informations d'annotation sont stockées dans l'attribut __annotations__ se prête à l'analyse des signatures de fonctions par des outils automatisés.
En fin de compte, les annotations n'ont rien de particulièrement magique.  Vous pourriez même définir les vôtres sans la syntaxe spéciale fournie par Python.  Voici une définition de fonction Python avec des annotations de type objet attachées aux paramètres et à la valeur de retour :
Ce qui suit est essentiellement la même fonction, avec le dictionnaire __annotations__ construit manuellement :
L'effet est identique dans les deux cas, mais le premier est plus attrayant visuellement et plus lisible au premier coup d'œil.
En fait, l'attribut __annotations__ n'est pas très différent de la plupart des autres attributs d'une fonction.  Par exemple, il peut être modifié dynamiquement.  Vous pouvez choisir d'utiliser l'attribut return value pour compter le nombre d'exécutions d'une fonction :
Les annotations de fonctions Python ne sont rien d'autre que des dictionnaires de métadonnées.  Il se trouve que vous pouvez les créer avec une syntaxe pratique qui est prise en charge par l'interpréteur.  Elles sont ce que vous décidez d'en faire.
\section{Conclusion}
Au fur et à mesure que les applications prennent de l'ampleur, il devient de plus en plus important de modulariser le code en le divisant en fonctions plus petites de taille gérable.  Vous disposez maintenant, je l'espère, de tous les outils nécessaires pour y parvenir.
Vous avez appris :
\begin{itemize}
\item Comment créer une fonction définie par l'utilisateur en Python ?
\item Il existe plusieurs façons de passer des arguments à une fonction
\item Comment renvoyer les données d'une fonction à son appelant ?
\item Comment ajouter de la documentation aux fonctions avec des docstrings et des annotations ?
\end{itemize}
Les deux prochains tutoriels de cette série traitent de la recherche et de la correspondance de motifs.  Vous aurez un aperçu approfondi d'un module Python appelé re, qui contient des fonctionnalités de recherche et de correspondance en utilisant une syntaxe de motif polyvalente appelée expression régulière.
 Répondez au quiz : Testez vos connaissances avec notre quiz interactif "Définir sa propre fonction Python". Vous recevrez un score à la fin du test pour vous aider à suivre vos progrès d'apprentissage :
Quiz interactif
Dans ce quiz, vous testerez votre compréhension de la définition de vos propres fonctions Python. Vous revisiterez à la fois les bases et la syntaxe plus complexe, comme les args et les kwargs, afin d'affiner votre connaissance des définitions de fonctions en Python.
 Regarder maintenant Ce tutoriel est accompagné d'un cours vidéo créé par l'équipe de Real Python. Regardez-le en même temps que le tutoriel écrit pour approfondir votre compréhension : Définir et appeler des fonctions Python